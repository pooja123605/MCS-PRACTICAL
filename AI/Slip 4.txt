Write a Program to find x y .     

SOLUTION

# Python3 program for the above approach

def power(x, n):
   # initialize result by 1
    pow = 1
    # Multiply x for n times
    for i in range(n):
        pow = pow * x
    return pow
# Driver code

if _name_ == '_main_':
  x = 2  n = 3

 # Function call
   print(power(x, n))
    
  Output: 8

2)Program to Implement Breadth first search Transversal     

Solution-ïƒ 
# Python3 Program to print BFS traversal 
# from a given source vertex. BFS(int s) 
# traverses vertices reachable from s. 
fromcollections importdefaultdict 
# This class represents a directed graph 
# using adjacency list representation 
classGraph: 
 # Constructor 
 def_init_(self): 
 # default dictionary to store graph 
 self.graph =defaultdict(list) 
 # function to add an edge to graph 
 defaddEdge(self,u,v): 
 self.graph[u].append(v) 
 # Function to print a BFS of graph 
 defBFS(self, s): 
 # Mark all the vertices as not visited 
 visited =[False] *(len(self.graph)) 
 # Create a queue for BFS 
 queue =[] 
 # Mark the source node as
 # visited and enqueue it 
 queue.append(s)
 visited[s] =True
 whilequeue: 
   # Dequeue a vertex from
 # queue and print it 
 s =queue.pop(0) 
 print(s, end =" ") 
 # Get all adjacent vertices of the 
 # dequeued vertex s. If a adjacent 
 # has not been visited, then mark it 
 # visited and enqueue it 
 fori inself.graph[s]: 
 ifvisited[i] ==False: 
 queue.append(i) 
 visited[i] =True
# Driver code 
# Create a graph given in 
# the above diagram 
g =Graph()
g.addEdge(0, 1) 
g.addEdge(0, 2) 
g.addEdge(1, 2) 
g.addEdge(2, 0) 
g.addEdge(2, 3) 
g.addEdge(3, 3) 
print("Following is Breadth First Traversal"
 " (starting from vertex 2)") 
g.BFS(2) 
Output:
Following is Breadth First Traversal (starting from vertex 2)
2 0 3 1                 

